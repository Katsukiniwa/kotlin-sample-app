/*
 * This file is generated by jOOQ.
 */
package nu.studer.sample.mysql.tables


import kotlin.collections.List

import nu.studer.sample.mysql.Mysql
import nu.studer.sample.mysql.keys.KEY_SLAVE_MASTER_INFO_PRIMARY

import org.jooq.Field
import org.jooq.ForeignKey
import org.jooq.Name
import org.jooq.Record
import org.jooq.Schema
import org.jooq.Table
import org.jooq.TableField
import org.jooq.TableOptions
import org.jooq.UniqueKey
import org.jooq.impl.DSL
import org.jooq.impl.Internal
import org.jooq.impl.SQLDataType
import org.jooq.impl.TableImpl
import org.jooq.types.UInteger
import org.jooq.types.ULong


/**
 * Master Information
 */
@Suppress("UNCHECKED_CAST")
open class SlaveMasterInfo(
    alias: Name,
    child: Table<out Record>?,
    path: ForeignKey<out Record, Record>?,
    aliased: Table<Record>?,
    parameters: Array<Field<*>?>?
): TableImpl<Record>(
    alias,
    Mysql.MYSQL,
    child,
    path,
    aliased,
    parameters,
    DSL.comment("Master Information"),
    TableOptions.table()
) {
    companion object {

        /**
         * The reference instance of <code>mysql.slave_master_info</code>
         */
        val SLAVE_MASTER_INFO = SlaveMasterInfo()
    }

    /**
     * The class holding records for this type
     */
    override fun getRecordType(): Class<Record> = Record::class.java

    /**
     * The column <code>mysql.slave_master_info.Number_of_lines</code>. Number of lines in the file.
     */
    val NUMBER_OF_LINES: TableField<Record, UInteger?> = createField(DSL.name("Number_of_lines"), SQLDataType.INTEGERUNSIGNED.nullable(false), this, "Number of lines in the file.")

    /**
     * The column <code>mysql.slave_master_info.Master_log_name</code>. The name of the master binary log currently being read from the master.
     */
    val MASTER_LOG_NAME: TableField<Record, String?> = createField(DSL.name("Master_log_name"), SQLDataType.CLOB.nullable(false), this, "The name of the master binary log currently being read from the master.")

    /**
     * The column <code>mysql.slave_master_info.Master_log_pos</code>. The master log position of the last read event.
     */
    val MASTER_LOG_POS: TableField<Record, ULong?> = createField(DSL.name("Master_log_pos"), SQLDataType.BIGINTUNSIGNED.nullable(false), this, "The master log position of the last read event.")

    /**
     * The column <code>mysql.slave_master_info.Host</code>. The host name of the master.
     */
    val HOST: TableField<Record, String?> = createField(DSL.name("Host"), SQLDataType.CHAR(64), this, "The host name of the master.")

    /**
     * The column <code>mysql.slave_master_info.User_name</code>. The user name used to connect to the master.
     */
    val USER_NAME: TableField<Record, String?> = createField(DSL.name("User_name"), SQLDataType.CLOB, this, "The user name used to connect to the master.")

    /**
     * The column <code>mysql.slave_master_info.User_password</code>. The password used to connect to the master.
     */
    val USER_PASSWORD: TableField<Record, String?> = createField(DSL.name("User_password"), SQLDataType.CLOB, this, "The password used to connect to the master.")

    /**
     * The column <code>mysql.slave_master_info.Port</code>. The network port used to connect to the master.
     */
    val PORT: TableField<Record, UInteger?> = createField(DSL.name("Port"), SQLDataType.INTEGERUNSIGNED.nullable(false), this, "The network port used to connect to the master.")

    /**
     * The column <code>mysql.slave_master_info.Connect_retry</code>. The period (in seconds) that the slave will wait before trying to reconnect to the master.
     */
    val CONNECT_RETRY: TableField<Record, UInteger?> = createField(DSL.name("Connect_retry"), SQLDataType.INTEGERUNSIGNED.nullable(false), this, "The period (in seconds) that the slave will wait before trying to reconnect to the master.")

    /**
     * The column <code>mysql.slave_master_info.Enabled_ssl</code>. Indicates whether the server supports SSL connections.
     */
    val ENABLED_SSL: TableField<Record, Byte?> = createField(DSL.name("Enabled_ssl"), SQLDataType.TINYINT.nullable(false), this, "Indicates whether the server supports SSL connections.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_ca</code>. The file used for the Certificate Authority (CA) certificate.
     */
    val SSL_CA: TableField<Record, String?> = createField(DSL.name("Ssl_ca"), SQLDataType.CLOB, this, "The file used for the Certificate Authority (CA) certificate.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_capath</code>. The path to the Certificate Authority (CA) certificates.
     */
    val SSL_CAPATH: TableField<Record, String?> = createField(DSL.name("Ssl_capath"), SQLDataType.CLOB, this, "The path to the Certificate Authority (CA) certificates.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_cert</code>. The name of the SSL certificate file.
     */
    val SSL_CERT: TableField<Record, String?> = createField(DSL.name("Ssl_cert"), SQLDataType.CLOB, this, "The name of the SSL certificate file.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_cipher</code>. The name of the cipher in use for the SSL connection.
     */
    val SSL_CIPHER: TableField<Record, String?> = createField(DSL.name("Ssl_cipher"), SQLDataType.CLOB, this, "The name of the cipher in use for the SSL connection.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_key</code>. The name of the SSL key file.
     */
    val SSL_KEY: TableField<Record, String?> = createField(DSL.name("Ssl_key"), SQLDataType.CLOB, this, "The name of the SSL key file.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_verify_server_cert</code>. Whether to verify the server certificate.
     */
    val SSL_VERIFY_SERVER_CERT: TableField<Record, Byte?> = createField(DSL.name("Ssl_verify_server_cert"), SQLDataType.TINYINT.nullable(false), this, "Whether to verify the server certificate.")

    /**
     * The column <code>mysql.slave_master_info.Heartbeat</code>.
     */
    val HEARTBEAT: TableField<Record, Double?> = createField(DSL.name("Heartbeat"), SQLDataType.FLOAT.nullable(false), this, "")

    /**
     * The column <code>mysql.slave_master_info.Bind</code>. Displays which interface is employed when connecting to the MySQL server
     */
    val BIND: TableField<Record, String?> = createField(DSL.name("Bind"), SQLDataType.CLOB, this, "Displays which interface is employed when connecting to the MySQL server")

    /**
     * The column <code>mysql.slave_master_info.Ignored_server_ids</code>. The number of server IDs to be ignored, followed by the actual server IDs
     */
    val IGNORED_SERVER_IDS: TableField<Record, String?> = createField(DSL.name("Ignored_server_ids"), SQLDataType.CLOB, this, "The number of server IDs to be ignored, followed by the actual server IDs")

    /**
     * The column <code>mysql.slave_master_info.Uuid</code>. The master server uuid.
     */
    val UUID: TableField<Record, String?> = createField(DSL.name("Uuid"), SQLDataType.CLOB, this, "The master server uuid.")

    /**
     * The column <code>mysql.slave_master_info.Retry_count</code>. Number of reconnect attempts, to the master, before giving up.
     */
    val RETRY_COUNT: TableField<Record, ULong?> = createField(DSL.name("Retry_count"), SQLDataType.BIGINTUNSIGNED.nullable(false), this, "Number of reconnect attempts, to the master, before giving up.")

    /**
     * The column <code>mysql.slave_master_info.Ssl_crl</code>. The file used for the Certificate Revocation List (CRL)
     */
    val SSL_CRL: TableField<Record, String?> = createField(DSL.name("Ssl_crl"), SQLDataType.CLOB, this, "The file used for the Certificate Revocation List (CRL)")

    /**
     * The column <code>mysql.slave_master_info.Ssl_crlpath</code>. The path used for Certificate Revocation List (CRL) files
     */
    val SSL_CRLPATH: TableField<Record, String?> = createField(DSL.name("Ssl_crlpath"), SQLDataType.CLOB, this, "The path used for Certificate Revocation List (CRL) files")

    /**
     * The column <code>mysql.slave_master_info.Enabled_auto_position</code>. Indicates whether GTIDs will be used to retrieve events from the master.
     */
    val ENABLED_AUTO_POSITION: TableField<Record, Byte?> = createField(DSL.name("Enabled_auto_position"), SQLDataType.TINYINT.nullable(false), this, "Indicates whether GTIDs will be used to retrieve events from the master.")

    /**
     * The column <code>mysql.slave_master_info.Channel_name</code>. The channel on which the slave is connected to a source. Used in Multisource Replication
     */
    val CHANNEL_NAME: TableField<Record, String?> = createField(DSL.name("Channel_name"), SQLDataType.CHAR(64).nullable(false), this, "The channel on which the slave is connected to a source. Used in Multisource Replication")

    /**
     * The column <code>mysql.slave_master_info.Tls_version</code>. Tls version
     */
    val TLS_VERSION: TableField<Record, String?> = createField(DSL.name("Tls_version"), SQLDataType.CLOB, this, "Tls version")

    private constructor(alias: Name, aliased: Table<Record>?): this(alias, null, null, aliased, null)
    private constructor(alias: Name, aliased: Table<Record>?, parameters: Array<Field<*>?>?): this(alias, null, null, aliased, parameters)

    /**
     * Create an aliased <code>mysql.slave_master_info</code> table reference
     */
    constructor(alias: String): this(DSL.name(alias))

    /**
     * Create an aliased <code>mysql.slave_master_info</code> table reference
     */
    constructor(alias: Name): this(alias, null)

    /**
     * Create a <code>mysql.slave_master_info</code> table reference
     */
    constructor(): this(DSL.name("slave_master_info"), null)

    constructor(child: Table<out Record>, key: ForeignKey<out Record, Record>): this(Internal.createPathAlias(child, key), child, key, SLAVE_MASTER_INFO, null)
    override fun getSchema(): Schema = Mysql.MYSQL
    override fun getPrimaryKey(): UniqueKey<Record> = KEY_SLAVE_MASTER_INFO_PRIMARY
    override fun getKeys(): List<UniqueKey<Record>> = listOf(KEY_SLAVE_MASTER_INFO_PRIMARY)
    override fun `as`(alias: String): SlaveMasterInfo = SlaveMasterInfo(DSL.name(alias), this)
    override fun `as`(alias: Name): SlaveMasterInfo = SlaveMasterInfo(alias, this)

    /**
     * Rename this table
     */
    override fun rename(name: String): SlaveMasterInfo = SlaveMasterInfo(DSL.name(name), null)

    /**
     * Rename this table
     */
    override fun rename(name: Name): SlaveMasterInfo = SlaveMasterInfo(name, null)
}
