/*
 * This file is generated by jOOQ.
 */
package nu.studer.sample.mysql.tables


import java.time.LocalDateTime

import nu.studer.sample.mysql.Mysql

import org.jooq.Field
import org.jooq.ForeignKey
import org.jooq.Name
import org.jooq.Record
import org.jooq.Schema
import org.jooq.Table
import org.jooq.TableField
import org.jooq.TableOptions
import org.jooq.impl.DSL
import org.jooq.impl.Internal
import org.jooq.impl.SQLDataType
import org.jooq.impl.TableImpl
import org.jooq.types.UInteger
import org.jooq.types.ULong


/**
 * General log
 */
@Suppress("UNCHECKED_CAST")
open class GeneralLog(
    alias: Name,
    child: Table<out Record>?,
    path: ForeignKey<out Record, Record>?,
    aliased: Table<Record>?,
    parameters: Array<Field<*>?>?
): TableImpl<Record>(
    alias,
    Mysql.MYSQL,
    child,
    path,
    aliased,
    parameters,
    DSL.comment("General log"),
    TableOptions.table()
) {
    companion object {

        /**
         * The reference instance of <code>mysql.general_log</code>
         */
        val GENERAL_LOG = GeneralLog()
    }

    /**
     * The class holding records for this type
     */
    override fun getRecordType(): Class<Record> = Record::class.java

    /**
     * The column <code>mysql.general_log.event_time</code>.
     */
    val EVENT_TIME: TableField<Record, LocalDateTime?> = createField(DSL.name("event_time"), SQLDataType.LOCALDATETIME(6).nullable(false).defaultValue(DSL.field("CURRENT_TIMESTAMP(6)", SQLDataType.LOCALDATETIME)), this, "")

    /**
     * The column <code>mysql.general_log.user_host</code>.
     */
    val USER_HOST: TableField<Record, String?> = createField(DSL.name("user_host"), SQLDataType.CLOB.nullable(false), this, "")

    /**
     * The column <code>mysql.general_log.thread_id</code>.
     */
    val THREAD_ID: TableField<Record, ULong?> = createField(DSL.name("thread_id"), SQLDataType.BIGINTUNSIGNED.nullable(false), this, "")

    /**
     * The column <code>mysql.general_log.server_id</code>.
     */
    val SERVER_ID: TableField<Record, UInteger?> = createField(DSL.name("server_id"), SQLDataType.INTEGERUNSIGNED.nullable(false), this, "")

    /**
     * The column <code>mysql.general_log.command_type</code>.
     */
    val COMMAND_TYPE: TableField<Record, String?> = createField(DSL.name("command_type"), SQLDataType.VARCHAR(64).nullable(false), this, "")

    /**
     * The column <code>mysql.general_log.argument</code>.
     */
    val ARGUMENT: TableField<Record, ByteArray?> = createField(DSL.name("argument"), SQLDataType.BLOB.nullable(false), this, "")

    private constructor(alias: Name, aliased: Table<Record>?): this(alias, null, null, aliased, null)
    private constructor(alias: Name, aliased: Table<Record>?, parameters: Array<Field<*>?>?): this(alias, null, null, aliased, parameters)

    /**
     * Create an aliased <code>mysql.general_log</code> table reference
     */
    constructor(alias: String): this(DSL.name(alias))

    /**
     * Create an aliased <code>mysql.general_log</code> table reference
     */
    constructor(alias: Name): this(alias, null)

    /**
     * Create a <code>mysql.general_log</code> table reference
     */
    constructor(): this(DSL.name("general_log"), null)

    constructor(child: Table<out Record>, key: ForeignKey<out Record, Record>): this(Internal.createPathAlias(child, key), child, key, GENERAL_LOG, null)
    override fun getSchema(): Schema = Mysql.MYSQL
    override fun `as`(alias: String): GeneralLog = GeneralLog(DSL.name(alias), this)
    override fun `as`(alias: Name): GeneralLog = GeneralLog(alias, this)

    /**
     * Rename this table
     */
    override fun rename(name: String): GeneralLog = GeneralLog(DSL.name(name), null)

    /**
     * Rename this table
     */
    override fun rename(name: Name): GeneralLog = GeneralLog(name, null)
}
